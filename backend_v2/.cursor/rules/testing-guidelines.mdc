---
globs: *.spec.ts,*.test.ts,test/**/*.ts
---

# Testing Guidelines

## Test Structure

- Unit tests: `*.spec.ts` files alongside source files
- E2E tests: [test/](mdc:test/) directory with `*.e2e-spec.ts` files
- Use Jest as the testing framework (configured in [package.json](mdc:package.json))

## Testing Commands

- `npm run test` - Run unit tests
- `npm run test:watch` - Run tests in watch mode
- `npm run test:cov` - Run tests with coverage
- `npm run test:e2e` - Run end-to-end tests
- `npm run test:debug` - Debug tests

## Unit Testing Patterns

```typescript
describe('ServiceName', () => {
  let service: ServiceName;
  let repository: Repository<Entity>;

  beforeEach(async () => {
    const module: TestingModule = await Test.createTestingModule({
      providers: [
        ServiceName,
        {
          provide: getRepositoryToken(Entity),
          useValue: mockRepository,
        },
      ],
    }).compile();

    service = module.get<ServiceName>(ServiceName);
    repository = module.get<Repository<Entity>>(getRepositoryToken(Entity));
  });

  it('should be defined', () => {
    expect(service).toBeDefined();
  });
});
```

## Mocking Guidelines

- Mock external dependencies (repositories, services, HTTP clients)
- Use `jest.fn()` for function mocks
- Create reusable mock factories for common objects
- Mock TypeORM repositories with standard CRUD methods

## Test Coverage

- Aim for high test coverage on business logic
- Focus on service layer testing
- Test error scenarios and edge cases
- Use coverage reports to identify untested code paths

## E2E Testing

- Test complete API workflows
- Use supertest for HTTP request testing
- Set up test database for E2E tests
- Clean up test data after each test

## Best Practices

- Write descriptive test names
- Use `describe` blocks to group related tests
- Keep tests isolated and independent
- Test both success and failure scenarios
- Use proper assertions with meaningful error messages
